{"columns": ["inputs", "query", "answer", "prompt_tokens", "answer_tokens", "sum_tokens"], "data": [["Answer the question based on the context below.\n\nContext:\n.ipynb\n.pdf\nConversationBufferMemory\n Contents \nUsing in a chain\nConversationBufferMemory#\nThis notebook shows how to use ConversationBufferMemory. This memory allows for storing of messages and then extracts the messages in a variable.\nWe can first extract it as a string.\nfrom langchain.memory import ConversationBufferMemory\nmemory = ConversationBufferMemory()\nmemory.save_context({\"input\": \"hi\"}, {\"ouput\": \"whats up\"})\nmemory.load_memory_variables({})\n{'history': 'Human: hi\\nAI: whats up'}\nWe can also get the history as a list of messages (this is useful if you are using this with a chat model).\nmemory = ConversationBufferMemory(return_messages=True)\nmemory.save_context({\"input\": \"hi\"}, {\"ouput\": \"whats up\"})\nmemory.load_memory_variables({})\n{'history': [HumanMessage(content='hi', additional_kwargs={}),\n  AIMessage(content='whats up', additional_kwargs={})]}\nUsing in a chain#\nFinally, let\u2019s take a look at using this in a chain (setting verbose=True so we can see the prompt).\nfrom langchain.llms import OpenAI\nfrom langchain.chains import ConversationChain\nllm = OpenAI(temperature=0)\nconversation = ConversationChain(\n    llm=llm, \n    verbose=True, \n    memory=ConversationBufferMemory()\n)\nconversation.predict(input=\"Hi there!\")\n> Entering new ConversationChain chain...\nPrompt after formatting:\nThe following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.\nCurrent conversation:\nHuman: Hi there!\nAI:\n> Finished chain.\n\n---\n\n.ipynb\n.pdf\nGetting Started\n Contents \nChatMessageHistory\nConversationBufferMemory\nUsing in a chain\nSaving Message History\nGetting Started#\nThis notebook walks through how LangChain thinks about memory.\nMemory involves keeping a concept of state around throughout a user\u2019s interactions with an language model. A user\u2019s interactions with a language model are captured in the concept of ChatMessages, so this boils down to ingesting, capturing, transforming and extracting knowledge from a sequence of chat messages. There are many different ways to do this, each of which exists as its own memory type.\nIn general, for each type of memory there are two ways to understanding using memory. These are the standalone functions which extract information from a sequence of messages, and then there is the way you can use this type of memory in a chain.\nMemory can return multiple pieces of information (for example, the most recent N messages and a summary of all previous messages). The returned information can either be a string or a list of messages.\nIn this notebook, we will walk through the simplest form of memory: \u201cbuffer\u201d memory, which just involves keeping a buffer of all prior messages. We will show how to use the modular utility functions here, then show how it can be used in a chain (both returning a string as well as a list of messages).\nChatMessageHistory#\nOne of the core utility classes underpinning most (if not all) memory modules is the ChatMessageHistory class. This is a super lightweight wrapper which exposes convienence methods for saving Human messages, AI messages, and then fetching them all.\nYou may want to use this class directly if you are managing memory outside of a chain.\nfrom langchain.memory import ChatMessageHistory\nhistory = ChatMessageHistory()\nhistory.add_user_message(\"hi!\")\nhistory.add_ai_message(\"whats up?\")\nhistory.messages\n[HumanMessage(content='hi!', additional_kwargs={}),\n\n---\n\n.ipynb\n.pdf\nConversationTokenBufferMemory\n Contents \nUsing in a chain\nConversationTokenBufferMemory#\nConversationTokenBufferMemory keeps a buffer of recent interactions in memory, and uses token length rather than number of interactions to determine when to flush interactions.\nLet\u2019s first walk through how to use the utilities\nfrom langchain.memory import ConversationTokenBufferMemory\nfrom langchain.llms import OpenAI\nllm = OpenAI()\nmemory = ConversationTokenBufferMemory(llm=llm, max_token_limit=10)\nmemory.save_context({\"input\": \"hi\"}, {\"ouput\": \"whats up\"})\nmemory.save_context({\"input\": \"not much you\"}, {\"ouput\": \"not much\"})\nmemory.load_memory_variables({})\n{'history': 'Human: not much you\\nAI: not much'}\nWe can also get the history as a list of messages (this is useful if you are using this with a chat model).\nmemory = ConversationTokenBufferMemory(llm=llm, max_token_limit=10, return_messages=True)\nmemory.save_context({\"input\": \"hi\"}, {\"ouput\": \"whats up\"})\nmemory.save_context({\"input\": \"not much you\"}, {\"ouput\": \"not much\"})\nUsing in a chain#\nLet\u2019s walk through an example, again setting verbose=True so we can see the prompt.\nfrom langchain.chains import ConversationChain\nconversation_with_summary = ConversationChain(\n    llm=llm, \n    # We set a very low max_token_limit for the purposes of testing.\n    memory=ConversationTokenBufferMemory(llm=OpenAI(), max_token_limit=60),\n    verbose=True\n)\nconversation_with_summary.predict(input=\"Hi, what's up?\")\n> Entering new ConversationChain chain...\nPrompt after formatting:\n\nQuestion: Tell me about ConversationBufferMemory in langchain, and walk me through how to use it.\nAnswer:", "Tell me about ConversationBufferMemory in langchain, and walk me through how to use it.", "ConversationBufferMemory is a memory module in LangChain that keeps a buffer of recent interactions in memory, and uses token length rather than number of interactions to determine when to flush interactions. To use it, first import the module from langchain.memory, then create an instance of the class, setting the max_token_limit parameter to the desired value. To save context, use the save_context() method, and to load the memory variables, use the load_memory_variables() method. To use it in a chain, create a ConversationChain instance, setting the memory parameter to an instance of ConversationBufferMemory.", 1140, 119, 1259], ["Answer the question based on the context below.\n\nContext:\nAction: Search\nAction Input: \"ChatGPT\"\nObservation: Nov 30, 2022 ... We've trained a model called ChatGPT which interacts in a conversational way. The dialogue format makes it possible for ChatGPT to answer\u00a0... ChatGPT is an artificial intelligence chatbot developed by OpenAI and launched in November 2022. It is built on top of OpenAI's GPT-3 family of large\u00a0... ChatGPT. We've trained a model called ChatGPT which interacts in a conversational way. The dialogue format makes it possible for ChatGPT to answer\u00a0... Feb 2, 2023 ... ChatGPT, the popular chatbot from OpenAI, is estimated to have reached 100 million monthly active users in January, just two months after\u00a0... 2 days ago ... ChatGPT recently launched a new version of its own plagiarism detection tool, with hopes that it will squelch some of the criticism around how\u00a0... An API for accessing new AI models developed by OpenAI. Feb 19, 2023 ... ChatGPT is an AI chatbot system that OpenAI released in November to show off and test what a very large, powerful AI system can accomplish. You\u00a0... ChatGPT is fine-tuned from GPT-3.5, a language model trained to produce text. ChatGPT was optimized for dialogue by using Reinforcement Learning with Human\u00a0... 3 days ago ... Visual ChatGPT connects ChatGPT and a series of Visual Foundation Models to enable sending and receiving images during chatting. Dec 1, 2022 ... ChatGPT is a natural language processing tool driven by AI technology that allows you to have human-like conversations and much more with a\u00a0...\nThought: I now know the final answer.\n\n---\n\nAction: Search\nAction Input: \"ChatGPT\"\nObservation: Nov 30, 2022 ... We've trained a model called ChatGPT which interacts in a conversational way. The dialogue format makes it possible for ChatGPT to answer\u00a0... ChatGPT is an artificial intelligence chatbot developed by OpenAI and launched in November 2022. It is built on top of OpenAI's GPT-3 family of large\u00a0... ChatGPT. We've trained a model called ChatGPT which interacts in a conversational way. The dialogue format makes it possible for ChatGPT to answer\u00a0... Feb 2, 2023 ... ChatGPT, the popular chatbot from OpenAI, is estimated to have reached 100 million monthly active users in January, just two months after\u00a0... 2 days ago ... ChatGPT recently launched a new version of its own plagiarism detection tool, with hopes that it will squelch some of the criticism around how\u00a0... An API for accessing new AI models developed by OpenAI. Feb 19, 2023 ... ChatGPT is an AI chatbot system that OpenAI released in November to show off and test what a very large, powerful AI system can accomplish. You\u00a0... ChatGPT is fine-tuned from GPT-3.5, a language model trained to produce text. ChatGPT was optimized for dialogue by using Reinforcement Learning with Human\u00a0... 3 days ago ... Visual ChatGPT connects ChatGPT and a series of Visual Foundation Models to enable sending and receiving images during chatting. Dec 1, 2022 ... ChatGPT is a natural language processing tool driven by AI technology that allows you to have human-like conversations and much more with a\u00a0...\nThought: I now know the final answer.\n\n---\n\nChatbots\\n\\nDocumentation\\n\\nEnd-to-end Example: Chat-LangChain\\n\\n\u00f0\\x9f\u00a4\\x96 Agents\\n\\nDocumentation\\n\\nEnd-to-end Example: GPT+WolframAlpha\\n\\n\u00f0\\x9f\u201c\\x96 Documentation\\n\\nPlease see here for full documentation on:\\n\\nGetting started (installation, setting up the environment, simple examples)\\n\\nHow-To examples (demos, integrations, helper functions)\\n\\nReference (full API docs)\\n  Resources (high-level explanation of core concepts)\\n\\n\u00f0\\x9f\\x9a\\x80 What can this help with?\\n\\nThere are six main areas that LangChain is designed to help with.\\nThese are, in increasing order of complexity:\\n\\n\u00f0\\x9f\u201c\\x83 LLMs and Prompts:\\n\\nThis includes prompt management, prompt optimization, generic interface for all LLMs, and common utilities for working with LLMs.\\n\\n\u00f0\\x9f\u201d\\x97 Chains:\\n\\nChains go beyond just a single LLM call, and are sequences of calls (whether to an LLM or a different utility). LangChain provides a standard interface for chains, lots of integrations with other tools, and end-to-end chains for common applications.\\n\\n\u00f0\\x9f\u201c\\x9a\n\nQuestion: What are chat bots and how do they work?\nAnswer:", "What are chat bots and how do they work?", "Chatbots are computer programs that are designed to simulate conversation with human users. They use natural language processing (NLP) to understand user input and respond with relevant information. Chatbots can be used to provide customer service, answer questions, and provide automated services. They can also be used to automate tasks, such as scheduling appointments or providing product recommendations.", 1049, 70, 1119], ["Answer the question based on the context below.\n\nContext:\nDataframe Agent\\nPython Agent\\nSQL Database Agent\\nVectorstore Agent\\n\\n\\nAgent Executors\\nHow to combine agents and vectorstores\\nHow to use the async API for Agents\\nHow to create ChatGPT Clone\\nHow to access intermediate steps\\nHow to cap the max number of iterations\\nHow to add SharedMemory to an Agent and its Tools\\n\\n\\n\\n\\n\\nUse Cases\\n\\nPersonal Assistants\\nQuestion Answering over Docs\\nChatbots\\nQuerying Tabular Data\\nInteracting with APIs\\nSummarization\\nExtraction\\nEvaluation\\nAgent Benchmarking: Search + Calculator\\nAgent VectorDB Question Answering Benchmarking\\nBenchmarking Template\\nData Augmented Question Answering\\nUsing Hugging Face Datasets\\nLLM Math\\nQuestion Answering Benchmarking: Paul Graham Essay\\nQuestion Answering Benchmarking: State of the Union Address\\nQA Generation\\nQuestion Answering\\nSQL Question Answering Benchmarking: Chinook\\n\\n\\n\\nReference\\n\\nInstallation\\nIntegrations\\nAPI References\\nPrompts\\nPromptTemplates\\nExample Selector\\n\\n\\nUtilities\\nPython REPL\\nSerpAPI\\nSearxNG Search\\nDocstore\\nText Splitter\\nEmbeddings\\nVectorStores\\n\\n\\nChains\\nAgents\\n\\n\\n\\nEcosystem\\n\\nLangChain Ecosystem\\nAI21 Labs\\nAtlasDB\\nBanana\\nCerebriumAI\\nChroma\\nCohere\\nDeepInfra\\nDeep\n\n---\n\n.rst\n.pdf\nAgents\n Contents \nGo Deeper\nAgents#\nNote\nConceptual Guide\nSome applications will require not just a predetermined chain of calls to LLMs/other tools,\nbut potentially an unknown chain that depends on the user\u2019s input.\nIn these types of chains, there is a \u201cagent\u201d which has access to a suite of tools.\nDepending on the user input, the agent can then decide which, if any, of these tools to call.\nIn this section of documentation, we first start with a Getting Started notebook to over over how to use all things related to agents in an end-to-end manner.\nWe then split the documentation into the following sections:\nTools\nAn overview of the various tools LangChain supports.\nAgents\nAn overview of the different agent types.\nToolkits\nAn overview of toolkits, and examples of the different ones LangChain supports.\nAgent Executor\nAn overview of the Agent Executor class and examples of how to use it.\nGo Deeper#\nTools\nAgents\nToolkits\nAgent Executors\nprevious\nChains\nnext\nGetting Started\n Contents\n  \nGo Deeper\nBy Harrison Chase\n    \n      \u00a9 Copyright 2023, Harrison Chase.\n      \n  Last updated on Mar 28, 2023.\n\n---\n\nAgent\\nJSON Agent\\nOpenAPI Agent\\nPandas Dataframe Agent\\nPython Agent\\nSQL Database Agent\\nVectorstore Agent\\nMRKL\\nMRKL Chat\\nReAct\\nSelf Ask With Search\\n\\n\\nReference\\n\\n\\nMemory\\nGetting Started\\nKey Concepts\\nHow-To Guides\\nConversationBufferMemory\\nConversationBufferWindowMemory\\nEntity Memory\\nConversation Knowledge Graph Memory\\nConversationSummaryMemory\\nConversationSummaryBufferMemory\\nConversationTokenBufferMemory\\nAdding Memory To an LLMChain\\nAdding Memory to a Multi-Input Chain\\nAdding Memory to an Agent\\nChatGPT Clone\\nConversation Agent\\nConversational Memory Customization\\nCustom Memory\\nMultiple Memory\\n\\n\\n\\n\\nChat\\nGetting Started\\nKey Concepts\\nHow-To Guides\\nAgent\\nChat Vector DB\\nFew Shot Examples\\nMemory\\nPromptLayer ChatOpenAI\\nStreaming\\nRetrieval Question/Answering\\nRetrieval Question Answering with Sources\\n\\n\\n\\n\\n\\nUse Cases\\n\\nAgents\\nChatbots\\nGenerate Examples\\nData Augmented Generation\\nQuestion Answering\\nSummarization\\nQuerying Tabular Data\\nExtraction\\nEvaluation\\nAgent Benchmarking: Search + Calculator\\nAgent VectorDB Question Answering Benchmarking\\nBenchmarking Template\\nData Augmented Question Answering\\nUsing Hugging Face Datasets\\nLLM Math\\nQuestion Answering Benchmarking: Paul Graham Essay\\nQuestion Answering Benchmarking: State of the Union Address\\nQA Generation\\nQuestion Answering\\nSQL Question Answering Benchmarking:\n\nQuestion: Explain autonomous agents and their applications.\nAnswer:", "Explain autonomous agents and their applications.", "Autonomous agents are computer programs that can act independently and autonomously in an environment to achieve a goal. They are used in a variety of applications, such as personal assistants, question answering over documents, chatbots, querying tabular data, interacting with APIs, summarization, extraction, evaluation, agent benchmarking, data augmented question answering, using Hugging Face datasets, LLM math, and SQL question answering benchmarking.", 876, 85, 961], ["Answer the question based on the context below.\n\nContext:\nStarted\\nModules\\nUse Cases\\nReference Docs\\nLangChain Ecosystem\\nAdditional Resources\\n\\n\\n\\n\\n\\n\\n\\n\\nWelcome to LangChain#\\nLarge language models (LLMs) are emerging as a transformative technology, enabling\\ndevelopers to build applications that they previously could not.\\nBut using these LLMs in isolation is often not enough to\\ncreate a truly powerful app - the real power comes when you are able to\\ncombine them with other sources of computation or knowledge.\\nThis library is aimed at assisting in the development of those types of applications. Common examples of these types of applications include:\\n\u2753 Question Answering over specific documents\\n\\nDocumentation\\nEnd-to-end Example: Question Answering over Notion Database\\n\\n\ud83d\udcac Chatbots\\n\\nDocumentation\\nEnd-to-end Example: Chat-LangChain\\n\\n\ud83e\udd16 Agents\\n\\nDocumentation\\nEnd-to-end Example: GPT+WolframAlpha\\n\\n\\nGetting Started#\\nCheckout the below guide for a walkthrough of how to get started using LangChain to create an Language Model application.\\n\\nGetting Started Documentation\\n\\n\\n\\n\\n\\nModules#\\nThere are several main modules that LangChain provides support for.\\nFor each module we provide some examples to\n\n---\n\n[Document(page_content=\"\u00f0\\x9f\u00a6\\x9c\u00ef\u00b8\\x8f\u00f0\\x9f\u201d\\x97 LangChain\\n\\n\u00e2\\x9a\u00a1 Building applications with LLMs through composability \u00e2\\x9a\u00a1\\n\\nProduction Support: As you move your LangChains into production, we'd love to offer more comprehensive support.\\nPlease fill out this form and we'll set up a dedicated support Slack channel.\\n\\nQuick Install\\n\\npip install langchain\\n\\n\u00f0\\x9f\u00a4\u201d What is this?\\n\\nLarge language models (LLMs) are emerging as a transformative technology, enabling\\ndevelopers to build applications that they previously could not.\\nBut using these LLMs in isolation is often not enough to\\ncreate a truly powerful app - the real power comes when you can combine them with other sources of computation or knowledge.\\n\\nThis library is aimed at assisting in the development of those types of applications. Common examples of these types of applications include:\\n\\n\u00e2\\x9d\u201c Question Answering over specific documents\\n\\nDocumentation\\n\\nEnd-to-end Example: Question Answering over Notion Database\\n\\n\u00f0\\x9f\u2019\u00ac Chatbots\\n\\nDocumentation\\n\\nEnd-to-end Example:\n\n---\n\nAgents: Agents involve an LLM making decisions about which Actions to take, taking that Action, seeing an Observation, and repeating that until done. LangChain provides a standard interface for agents, a selection of agents to choose from, and examples of end to end agents.\nUse Cases#\nThe above modules can be used in a variety of ways. LangChain also provides guidance and assistance in this. Below are some of the common use cases LangChain supports.\nPersonal Assistants: The main LangChain use case. Personal assistants need to take actions, remember interactions, and have knowledge about your data.\nQuestion Answering: The second big LangChain use case. Answering questions over specific documents, only utilizing the information in those documents to construct an answer.\nChatbots: Since language models are good at producing text, that makes them ideal for creating chatbots.\nQuerying Tabular Data: If you want to understand how to use LLMs to query data that is stored in a tabular format (csvs, SQL, dataframes, etc) you should read this page.\nInteracting with APIs: Enabling LLMs to interact with APIs is extremely powerful in order to give them more up-to-date information and allow them to take actions.\nExtraction: Extract structured information from text.\nSummarization: Summarizing longer documents into shorter, more condensed chunks of information. A type of Data Augmented Generation.\nEvaluation: Generative models are notoriously hard to evaluate with traditional metrics. One new way of evaluating them is using language models themselves to do the evaluation. LangChain provides some prompts/chains for assisting in this.\nReference Docs#\nAll of LangChain\u2019s reference documentation, in one place. Full documentation on all methods, classes, installation methods, and integration setups for LangChain.\nReference Documentation\nLangChain Ecosystem#\nGuides for how other companies/products can be used with LangChain\nLangChain Ecosystem\n\nQuestion: Describe LLMChains and their role in langchain.\nAnswer:", "Describe LLMChains and their role in langchain.", "LLMChains are a type of application that combines large language models (LLMs) with other sources of computation or knowledge to create powerful applications. Examples of LLMChains include question answering over specific documents, chatbots, agents, personal assistants, querying tabular data, interacting with APIs, extraction, summarization, and evaluation.", 932, 68, 1000], ["Answer the question based on the context below.\n\nContext:\nwhen that information is available.\nprevious\nStochasticAI\nnext\nWeights & Biases\n Contents\n  \nInstallation and Setup\nWrappers\nData Loaders\nBy Harrison Chase\n    \n      \u00a9 Copyright 2023, Harrison Chase.\n      \n  Last updated on Mar 28, 2023.\n\n---\n\nWe intend this to be a collection of open source datasets for evaluating common chains and agents.\nWe have contributed five datasets of our own to start, but we highly intend this to be a community effort.\nIn order to contribute a dataset, you simply need to join the community and then you will be able to upload datasets.\nWe\u2019re also aiming to make it as easy as possible for people to create their own datasets.\nAs a first pass at this, we\u2019ve added a QAGenerationChain, which given a document comes up\nwith question-answer pairs that can be used to evaluate question-answering tasks over that document down the line.\nSee this notebook for an example of how to use this chain.\n# 2: Lack of metrics\nWe have two solutions to the lack of metrics.\nThe first solution is to use no metrics, and rather just rely on looking at results by eye to get a sense for how the chain/agent is performing.\nTo assist in this, we have developed (and will continue to develop) tracing, a UI-based visualizer of your chain and agent runs.\nThe second solution we recommend is to use Language Models themselves to evaluate outputs.\nFor this we have a few different chains and prompts aimed at tackling this issue.\nThe Examples#\nWe have created a bunch of examples combining the above two solutions to show how we internally evaluate chains and agents when we are developing.\nIn addition to the examples we\u2019ve curated, we also highly welcome contributions here.\nTo facilitate that, we\u2019ve included a template notebook for community members to use to build their own examples.\nThe existing examples we have are:\nQuestion Answering (State of Union): An notebook showing evaluation of a question-answering task over a State-of-the-Union address.\nQuestion Answering (Paul Graham Essay): An notebook showing evaluation of a question-answering task over a Paul Graham essay.\n\n---\n\nhave knowledge about your data.\\nQuestion Answering: The second big LangChain use case. Answering questions over specific documents, only utilizing the information in those documents to construct an answer.\\nChatbots: Since language models are good at producing text, that makes them ideal for creating chatbots.\\nQuerying Tabular Data: If you want to understand how to use LLMs to query data that is stored in a tabular format (csvs, SQL, dataframes, etc) you should read this page.\\nInteracting with APIs: Enabling LLMs to interact with APIs is extremely powerful in order to give them more up-to-date information and allow them to take actions.\\nExtraction: Extract structured information from text.\\nSummarization: Summarizing longer documents into shorter, more condensed chunks of information. A type of Data Augmented Generation.\\nEvaluation: Generative models are notoriously hard to evaluate with traditional metrics. One new way of evaluating them is using language models themselves to do the evaluation. LangChain provides some prompts/chains for assisting in this.\\n\\n\\n\\n\\n\\nReference Docs#\\nAll\n\nQuestion: What is Weights and Biases and how is it used in machine learning?\nAnswer:", "What is Weights and Biases and how is it used in machine learning?", "Weights and Biases is a tool for tracking, visualizing, and understanding machine learning experiments. It helps machine learning engineers and data scientists track their experiments, compare results, and share their findings with others. It can be used to track metrics, hyperparameters, model weights, and other data associated with machine learning experiments.", 705, 64, 769]]}